// Minimal JWT encode/decode for browser (HS256, no dependencies)
// Only for demo/dev, not for production security!
// This is NOT a full crypto implementation, but enough for local JWT auth with known secret.
// For real crypto, use a library like jsrsasign or jose.

function base64url(source) {
  // Encode in classical base64
  let encodedSource = btoa(String.fromCharCode.apply(null, new Uint8Array(source)));
  // Remove padding equal characters
  encodedSource = encodedSource.replace(/=+$/, '');
  // Replace characters according to base64url specifications
  encodedSource = encodedSource.replace(/\+/g, '-');
  encodedSource = encodedSource.replace(/\//g, '_');
  return encodedSource;
}

async function sha256(message) {
  // encode as UTF-8
  const msgBuffer = new TextEncoder().encode(message);
  // hash the message
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
  return new Uint8Array(hashBuffer);
}

async function hmacSHA256(key, message) {
  const enc = new TextEncoder();
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    enc.encode(key),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign', 'verify']
  );
  const sig = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));
  return new Uint8Array(sig);
}

async function jwtEncode(payload, secret) {
  const header = { alg: 'HS256', typ: 'JWT' };
  const enc = new TextEncoder();
  const headerBase64 = base64url(enc.encode(JSON.stringify(header)));
  const payloadBase64 = base64url(enc.encode(JSON.stringify(payload)));
  const data = headerBase64 + '.' + payloadBase64;
  const signature = await hmacSHA256(secret, data);
  const signatureBase64 = base64url(signature);
  return data + '.' + signatureBase64;
}

window.jwtEncode = jwtEncode; // Expose for global use
